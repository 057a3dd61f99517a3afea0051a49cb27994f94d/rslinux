#!/usr/bin/env perl
=license

	Copyright Â© 2018 Yang Bo

	This file is part of RSLinux.

	RSLinux is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	RSLinux is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with RSLinux.  If not, see <http://www.gnu.org/licenses/>.

=cut
use App::rs 'sane', 'constant',
    iautoload => [qw/App::rs Term::ANSIColor Cwd/,
		  ['List::Util', map { '0' . $_ } qw/reduce all/]];

main();

sub set {
	my ($f, $m) = @_;
	# chown should be called before chmod to prevent setuid, setgid bit gets reset.
	chown @$m{qw/uid gid/}, $f and chmod $m->{mode} & 07777, $f and utimensat($f, $m->{mtime}) or die "$f: $!";
}
sub equiv {
	my ($p, $q) = @_;
	no warnings 'uninitialized';
	all { $p->{$_} eq $q->{$_} } qw/mode uid gid size mtime hl sl/;
}
sub elf {
	open my $fh, '<', shift or die $!;
	my $b;
	read($fh, $b, 4) == 4 and $b eq "\x7fELF";
}
sub strip {
	my ($f, $m, $root) = @_;
	my $s;
	if (/\.[ao]$/)						{ @$s{qw/strip archive/} = (1, 1) }
	elsif ((/\.so/ or $m->{mode} & 0111) and elf($f))	{ $s->{strip} = 1 }
	if ($s->{strip}) {
		xsh(0, 'strip', $s->{archive} ? '--strip-unneeded' : (), $f);
		say "strip on $f, st: $?.";
		if (not $?) {
			set($f, $m);
			$m->{size} = (stat $f)[7];
		}
	}
}
sub diff {
	my ($cp, $vp) = @_;
	my ($db, $v) = ($vp->{db}, {});
	opendir(my $dh, $cp->{root} . $vp->{d}) or die $!;
	for (sort readdir $dh) {
		my $ign = $vp->{ign}{$_};
		# ignore leaf only.
		next if /^\.{1,2}$/ or $ign and not ref $ign;
		my ($r, $m) = ($vp->{d} . $_, {});
		my $f = $cp->{root} . $r;
		(my $i, @$m{qw/mode uid gid size mtime/}) = (lstat $f)[1, 2, 4, 5, 7, 9];
		if ($cp->{ih}{$i})	{ $m->{hl} = $cp->{ih}{$i} }
		else			{ $cp->{ih}{$i} = $r }
		my $t = $m->{mode} & S_IFMT;
		if ($t == S_IFDIR)	{ delete $m->{size} }
		elsif ($t == S_IFLNK)	{ $m->{sl} = readlink $f or die $! }
		elsif ($t != S_IFREG)	{ die "unknown type $t of $f." }
		my $st = {};
		if (my $_m = $db->{$_}) {
			my $_t = $_m->{mode} & S_IFMT;
			if ($t == S_IFDIR xor $_t == S_IFDIR)	{ ... }
			elsif ($t == S_IFDIR)			{ $st->{dir} = 1 }
			else					{ $st->{mod} = 1 if not equiv($m, $_m) }
		} else {
			$st->{ne} = 1;
		}
		if (%$st) {
			if ($t == S_IFDIR) {
				add(my $p = $db->{$_} ||= {c => {}}, %$m);
				my $c = diff($cp, {db => $p->{c},
						   ign => $vp->{ign}{$_},
						   d => $r . '/'});
				if ($st->{ne} or %$c) {
					$v->{$_} = {%$m,
						    c => $c};
					$p->{owner}{$cp->{oid}} = $cp->{ts};
				}
			} else {
				my $n = 1 if $t == S_IFREG and not $m->{hl};
				strip($f, $m) if $n;
				add(my $p = $db->{$_} ||= {}, %$m);
				$p->{owner}{current} = $cp->{oid}, $p->{owner}{record}{$cp->{oid}} = $cp->{ts};
				$v->{$_} = {%$m};
				$v->{$_}{c} = \$f if $n;
			}
		}
	}
	$v;
}
sub patch {
	my ($cp, $vp) = @_;
	my ($db, $v) = @$vp{qw/db v/};
	for (sort keys %$v) {
		my ($r, $q) = ($vp->{d} . $_, $v->{$_});
		my $f = $cp->{root} . $r;
		# That's for historical reasons...
		my $t = $q->{sl} ? S_IFLNK : $q->{mode} & S_IFMT;
		if ($t == S_IFDIR) {
			if (not $db->{$_}) {
				mkdir $f or die "mkdir $f: $!";
				$db->{$_} = {%$q,
					     c => {}};
			}
			my $p = $db->{$_};
			patch($cp, {v => $q->{c},
				    db => $p->{c},
				    d => $r . '/'});
			set($f, $p) if not $p->{owner};
			$p->{owner}{$cp->{oid}} = $cp->{ts};
		} else {
			unlink $f or die "$f exists but unable to unlink." if -e $f;
			if ($t == S_IFREG) {
				if ($q->{hl}) {
					my $g = $cp->{root} . $q->{hl};
					link $g, $f or die "unable to hard link $f to $g: $!";
				} else {
					wf($f, delete $q->{c});
					set($f, $q);
				}
			} else {
				symlink $q->{sl}, $f or die "unable to symlink $f to $q->{sl}: $!.";
				# symlink(7) explicitly says the permission of a symbolic link can't be changed(on Linux).
				lchown($f, @$q{qw/uid gid/}) and utimensat($f, $q->{mtime}) or die "$f: $!";
			}
			add(my $p = $db->{$_} ||= {}, %$q);
			$p->{owner}{current} = $cp->{oid}, $p->{owner}{record}{$cp->{oid}} = $cp->{ts};
		}
	}
}
# merge two patch trees, the first one takes higher priority.
sub merge {
	my ($p, $q) = @_;
	for (keys %$q) {
		if (not $p->{$_}) {
			$p->{$_} = $q->{$_};
		} else {
			my ($t, $_t) = ($p->{$_}{mode} & S_IFMT, $q->{$_}{mode} & S_IFMT);
			if ($t == S_IFDIR xor $_t == S_IFDIR)	{ ... }
			elsif ($t == S_IFDIR)			{ merge($p->{$_}{c}, $q->{$_}{c}) }
		}
	}
}
# add path r from v to p.
sub grow {
	my ($p, $v, $r) = @_;
	my @d = split m|/|, $r;
	my $f = pop @d;
	for (@d) {
		$p->{$_} = {%{$v->{$_}},
			    c => {}} if not $p->{$_};
		$p = $p->{$_}{c}, $v = $v->{$_}{c};
	}
	$p->{$f} = $v->{$f};
}
sub rm {
	my ($cp, $vp) = @_;
	my $db = $vp->{db};
	for (keys %$db) {
		my ($r, $p, $o) = ($vp->{d} . $_, $db->{$_}, $db->{$_}{owner});
		my $f = $cp->{root} . $r;
		if ($p->{c}) {
			if ($o->{$cp->{oid}}) {
				rm($cp, {db => $p->{c},
					 d => $r . '/'});
				delete $o->{$cp->{oid}};
				if (not %$o) {
					rmdir $f or die "unable to rmdir $f: $!.";
					delete $db->{$_};
				}
			}
		} else {
			my $d = $o->{record};
			if (delete $d->{$cp->{oid}}) {
				if ($o->{current} eq $cp->{oid}) {
					unlink $f or warn "unable to unlink $f: $!.";
					if (%$d) {
						my $oid = reduce { $d->{$b} > $d->{$a} ? $b : $a } keys %$d;
						my $p = $cp->{patch}{$oid} ||= {v => rs_parse($cp->{pool} . $oid . '.rs'),
										p => {}};
						grow(@$p{qw/p v/}, $r);
					} else {
						delete $db->{$_};
					}
				}
			}
		}
	}
}
sub wf {
	my $f = shift;
	unlink $f or die "$!: unable to remove $f for writing.\n" if -e $f;
	open my $fh, '>', $f or die "open $f for writing: $!";
	if (@_)	{ syswrite $fh, shift }
	else	{ $fh }
}
sub runas {
	my $u = shift;
	if ($u ne 'root') {
		my ($uid, $gid) = (getpwnam $u)[2, 3];
		($(, $)) = ($gid, "$gid $gid");
		setresuid($uid, $uid, 0);
	} else {
		setresuid(0, 0, 0);
		($(, $)) = (0, '0 0');
	}
}
sub tag {
	my ($cp, $vp) = @_;
	my ($v, $oid, $db, $d) = ({}, $cp->{oid}, @$vp{qw/db d/});
	say {$cp->{sink}} $d;
	for (keys %$db) {
		my ($p, $r) = ($db->{$_}, $d . $_);
		if ($p->{c}) {
			$v->{$_} = {%$p,
				    c => tag($cp, {db => $p->{c},
						   d => $r . '/'})} if $p->{owner}{$oid};
		} else {
			$v->{$_} = $p, say {$cp->{sink}} $r if $p->{owner}{record}{$oid};
		}
	}
	$v;
}
sub confirm ($) {
	state $s = colored(['bright_green'], 'yes') . ' or ' .
	    colored(['bright_red'], 'no') . ': ';
	print shift, ', ', $s;
	while (1) {
		chomp(my $a = <STDIN>);
		return 1 if $a eq 'yes';
		return 0 if $a eq 'no';
		print "Please answer $s";
	}
}
sub main {
	my $s;
	do {
		my $c = arg_parse();
		$s = do($c->{profile} || "$ENV{HOME}/.rs.profile");
		add($s, %$c);
		$s->{prefix} ||= $s->{root};
	};
	print 'run-time config: ', json_unparse_readable($s);
	# mod tells us whether the database is modified.
	my ($db, $mod) = -f $s->{db} ? rs_parse($s->{db}) : {};
	while (@ARGV) {
		my $op = shift @ARGV;
		if ($op eq 'diff') {
			my $oid = shift @ARGV;
			my ($p, $_v) = $s->{pool} . $oid . '.rs';
			if (-e $p) {
				say "$p exists, will merge with new generated patch tree.";
				$_v = rs_parse($p);
			}
			my $v = diff({ih => {},
				      root => $s->{root},
				      oid => $oid,
				      ts => time}, {db => $db,
						    ign => $s->{ign} ? do $s->{ign} || die "$s->{ign} is bad.\n" : undef,
						    d => ''});
			$mod = 1;
			merge($v, $_v) if $_v;
			rs_unparse($v, fileno wf($p));
		} elsif ($op eq 'patch') {
			my $f = shift @ARGV;
			#   v is the parsed value of the patch, and can be cut using subtree switch,
			# the final patch to apply is stored in p.
			my $v = my $p = rs_parse($f);
			if (exists $s->{subtree}) {
				$p = {};
				grow($p, $v, $_) for flatten($s->{subtree});
			}
			my ($oid) = $f =~ m|([^/]*).rs$|;
			patch({root => $s->{root},
			       oid => $oid,
			       ts => time}, {v => $p,
					     db => $db,
					     d => ''});
			$mod = 1;
		} elsif ($op eq 'remove') {
			my $oid = shift @ARGV;
			rm({root => $s->{root},
			    oid => $oid,
			    pool => $s->{pool},
			    patch => my $p = {}}, {db => $db,
						   d => ''});
			$mod = 1;
			my $ts = time;
			for (keys %$p) {
				patch({root => $s->{root},
				       oid => $_,
				       ts => $ts}, {v => $p->{$_}{p},
						    db => $db,
						    d => ''});
			}
		} elsif ($op eq 'compile') {
			my $root;
			if ($root = not $>) {
				# drop root privilege before compile, as suggested by many packages.
				my $u = $s->{'compile-as'} || $ENV{USER};
				if ($u eq 'root') {
					say color('bold red'), 'You are compiling as root!', color('reset');
					$root = 0;
				} else {
					runas($u);
				}
			}
			my $o = getcwd();
			chdir($s->{'compile-in'} || '.') or die $!;
			my ($p, $oid, $pkg, $d) = abs_path(shift @ARGV);
			if (-d $p) {
				$oid = shift @ARGV;
				if ($s->{prepared}) {
					$d = $p;
				} else {
					mkdir $d = $oid or die $!;
					xsh(0, qw/git clone --shared/, '--branch=' . ($s->{branch} || $oid),
					    $p, $d);
				}
			} else {
				($oid) = $p =~ m|([^/]*).tar.\w+$|;
				($d) = (xsh(1, qw/tar -xvf/, $p))[0] =~ m|([^/\n]*)| or die 'bad tarball.';
			}
			($pkg) = $s->{package} || $oid =~ m|(.*)-|;
			chdir $d or die "chdir $d: $!.";
			my $b = do {
				my ($b, $v) = (do $s->{build}, $pkg);
				$b = $b->($s);
				$v = $b->{$v} until ref $v or not defined $v;
				$v;
			};
			xsh({'feed-stdin' => 1}, $b->{'pre-configure'}, 'bash') or die 'pre-configure failed.' if $b->{'pre-configure'};
			unless ($b->{'no-configure'}) {
				local %ENV = %ENV;
				xsh(0, qw/autoreconf -iv/) or die 'autoreconf failed.' unless -e 'configure';
				my @p;
				if ($s->{bootstrap}) {
					$ENV{CPPFLAGS} = "-I$s->{prefix}/include" unless $b->{'no-cppflags'};
					$ENV{LDFLAGS} = "-L$s->{prefix}/lib -Wl,-I" . linker($s);
				}
				push @p, "--prefix=$s->{prefix}";
				my $e = $b->{environment};
				$ENV{$_} = $e->{$_} for keys %$e;
				xsh(0, './configure', @{$b->{switch}}, @p,
				    {to => *STDERR,
				     from => *STDOUT,
				     mode => '>'}, qw/| less --quit-on-intr --RAW-CONTROL-CHARS/) or die 'configure failed.';
			}
			xsh({'feed-stdin' => 1}, $b->{'post-configure'}, 'bash') or die 'post-configure failed.' if $b->{'post-configure'};
			xsh(0, 'make', $s->{jobs} ? "--jobs=$s->{jobs}" : (), @{$b->{'make-parameter'}}) or die 'make failed.' unless $b->{'no-make'};
			xsh({'feed-stdin' => 1}, $b->{'post-make'}, 'bash') or die 'post-make failed.' if $b->{'post-make'};
			# since the following is installation process we need to switch back to root.
			runas('root') if $root;
			xsh(0, qw/make install/, @{$b->{'make-install-parameter'}}) or die 'make install failed.';
			xsh({'feed-stdin' => 1}, $b->{'post-make-install'}, 'bash') or die 'post-make failed.' if $b->{'post-make-install'};
			# do some cleaning.
			unless ($s->{prepared} or $s->{'no-rm'}) {
				my $cwd = getcwd();
				xsh(0, qw/rm -rf/, "../$d") if confirm "'rm -rf ../$d' on $cwd";
			}
			# return to where we started.
			chdir $o or die "chdir $o: $!.";
			# the next steps.
			push @ARGV, 'diff', $oid, 'tag', $oid;
		} elsif ($op eq 'tag') {
			my ($oid, $pid) = shift @ARGV;
			local $SIG{PIPE} = 'IGNORE';
			do {
				pipe my $r, my $w or die $!;
				$pid = xsh({asynchronous => 1},
					   qw/less -R/, {to => *STDIN,
							 from => $r,
							 mode => '<'});
				close $r;
				print $w json_unparse_readable(tag({oid => $oid,
								    sink => $w}, {db => $db,
										  d => ''}));
			};
			# we must wait here or we will lose control-terminal.
			waitpid $pid, 0;
		}
	}
	rs_unparse($db, fileno wf($s->{db})) if $mod;
}
