#!/usr/bin/env perl

#   Copyright Â© 2018 Yang Bo
#
#   This file is part of RSLinux.
#
#   RSLinux is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   RSLinux is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with RSLinux.  If not, see <http://www.gnu.org/licenses/>.

use App::rs 'sane', 'constant',
    iautoload => [qw/App::rs Term::ANSIColor Cwd/,
		  ['List::Util', map { '0' . $_ } qw/reduce all/]];

main();

sub set {
	my ($f, $m) = @_;
	# chown should be called before chmod to prevent setuid, setgid bit gets reset.
	chown @$m{qw/uid gid/}, $f and chmod $m->{mode} & 07777, $f and utimensat($f, $m->{mtime}) or die "$f: $!";
}
sub equiv {
	my ($p, $q) = @_;
	no warnings 'uninitialized';
	all { $p->{$_} eq $q->{$_} } qw/mode uid gid size mtime hl sl/;
}
sub elf {
	open my $fh, '<', shift or die $!;
	my $b;
	read($fh, $b, 4) == 4 and $b eq "\x7fELF";
}
sub strip {
	my ($f, $m, $root) = @_;
	my $s;
	if (/\.[ao]$/)						{ @$s{qw/strip archive/} = (1, 1) }
	elsif ((/\.so/ or $m->{mode} & 0111) and elf($f))	{ $s->{strip} = 1 }
	if ($s->{strip}) {
		xsh(0, 'strip', $s->{archive} ? '--strip-unneeded' : (), $f);
		say "strip on $f, st: $?.";
		if (not $?) {
			set($f, $m);
			$m->{size} = (stat $f)[7];
		}
	}
}
sub diff {
	my ($cp, $vp) = @_;
	my ($db, $v) = ($vp->{db}, {});
	opendir(my $dh, $cp->{root} . $vp->{d}) or die $!;
	for (sort readdir $dh) {
		my $ign = $vp->{ign}{$_};
		# ignore leaf only.
		next if /^\.{1,2}$/ or $ign and not ref $ign;
		my ($r, $m) = ($vp->{d} . $_, {});
		my $f = $cp->{root} . $r;
		(my $i, @$m{qw/mode uid gid size mtime/}) = (lstat $f)[1, 2, 4, 5, 7, 9];
		if ($cp->{ih}{$i})	{ $m->{hl} = $cp->{ih}{$i} }
		else			{ $cp->{ih}{$i} = $r }
		my $t = $m->{mode} & S_IFMT;
		if ($t == S_IFDIR)	{ delete $m->{size} }
		elsif ($t == S_IFLNK)	{ $m->{sl} = readlink $f or die $! }
		elsif ($t != S_IFREG)	{ die "unknown type $t of $f." }
		my $st = {};
		if (my $_m = $db->{$_}) {
			my $_t = $_m->{mode} & S_IFMT;
			if ($t == S_IFDIR xor $_t == S_IFDIR)	{ ... }
			elsif ($t == S_IFDIR)			{ $st->{dir} = 1 }
			else					{ $st->{mod} = 1 if not equiv($m, $_m) }
		} else {
			$st->{ne} = 1;
		}
		if (%$st) {
			if ($t == S_IFDIR) {
				add(my $p = $db->{$_} ||= {c => {}}, %$m);
				my $c = diff($cp, {db => $p->{c},
						   ign => $vp->{ign}{$_},
						   d => $r . '/'});
				if ($st->{ne} or %$c) {
					$v->{$_} = {%$m,
						    c => $c};
					$p->{owner}{$cp->{oid}} = $cp->{ts};
				}
			} else {
				my $n = 1 if $t == S_IFREG and not $m->{hl};
				strip($f, $m) if $n;
				my $p = $db->{$_} = {%$m,
						     owner => $db->{$_}{owner}};
				$p->{owner}{current} = $cp->{oid}, $p->{owner}{record}{$cp->{oid}} = $cp->{ts};
				$v->{$_} = {%$m};
				$v->{$_}{c} = \$f if $n;
			}
		}
	}
	$v;
}
sub patch {
	my ($cp, $vp) = @_;
	my ($db, $v) = @$vp{qw/db v/};
	for (sort keys %$v) {
		my ($r, $q) = ($vp->{d} . $_, $v->{$_});
		my $f = $cp->{root} . $r;
		# That's for historical reasons...
		my $t = $q->{sl} ? S_IFLNK : $q->{mode} & S_IFMT;
		if ($t == S_IFDIR) {
			if (not $db->{$_}) {
				mkdir $f or die "mkdir $f: $!";
				$db->{$_} = {%$q,
					     c => {}};
			}
			my $p = $db->{$_};
			patch($cp, {v => $q->{c},
				    db => $p->{c},
				    d => $r . '/'});
			set($f, $p) if not $p->{owner};
			$p->{owner}{$cp->{oid}} = $cp->{ts};
		} else {
			unlink $f or die "$f exists but unable to unlink." if -e $f;
			if ($t == S_IFREG) {
				if ($q->{hl}) {
					my $g = $cp->{root} . $q->{hl};
					link $g, $f or die "unable to hard link $f to $g: $!";
				} else {
					wf($f, delete $q->{c});
					set($f, $q);
				}
			} else {
				# That's really nasty...
				symlink my $g = $q->{sl}, $f or die "unable to symlink $f to $q->{sl}: $!.";
				# symlink(7) explicitly says the permission of a symbolic link can't be changed(on Linux).
				lchown($f, @$q{qw/uid gid/}) and utimensat($f, $q->{mtime}) or die "$f: $!";
			}
			# A new hash is required here and above since metadata varies for non-directory.
			my $p = $db->{$_} = {%$q,
					     owner => $db->{$_}{owner}};
			$p->{owner}{current} = $cp->{oid}, $p->{owner}{record}{$cp->{oid}} = $cp->{ts};
		}
	}
}
# merge two patch trees, the first one takes higher priority.
sub merge {
	my ($p, $q) = @_;
	for (keys %$q) {
		if (not $p->{$_}) {
			$p->{$_} = $q->{$_};
		} else {
			my ($t, $_t) = ($p->{$_}{mode} & S_IFMT, $q->{$_}{mode} & S_IFMT);
			if ($t == S_IFDIR xor $_t == S_IFDIR)	{ ... }
			elsif ($t == S_IFDIR)			{ merge($p->{$_}{c}, $q->{$_}{c}) }
		}
	}
}
# add path r from v to p.
sub grow {
	my ($p, $v, $r) = @_;
	my @d = split m|/|, $r;
	my $f = pop @d;
	for (@d) {
		$p->{$_} = {%{$v->{$_}},
			    c => {}} if not $p->{$_};
		$p = $p->{$_}{c}, $v = $v->{$_}{c};
	}
	$p->{$f} = $v->{$f};
}
sub rm {
	my ($cp, $vp) = @_;
	my $db = $vp->{db};
	for (keys %$db) {
		my ($r, $p, $o) = ($vp->{d} . $_, $db->{$_}, $db->{$_}{owner});
		my $f = $cp->{root} . $r;
		if ($p->{c}) {
			if ($o->{$cp->{oid}}) {
				rm($cp, {db => $p->{c},
					 d => $r . '/'});
				delete $o->{$cp->{oid}};
				if (not %$o) {
					rmdir $f or die "unable to rmdir $f: $!.";
					delete $db->{$_};
				}
			}
		} else {
			my $d = $o->{record};
			if (delete $d->{$cp->{oid}}) {
				if ($o->{current} eq $cp->{oid}) {
					unlink $f or warn "unable to unlink $f: $!.";
					if (%$d) {
						my $oid = reduce { $d->{$b} > $d->{$a} ? $b : $a } keys %$d;
						my $p = $cp->{patch}{$oid} ||= {v => rs_parse($cp->{pool} . $oid . '.rs'),
										p => {}};
						grow(@$p{qw/p v/}, $r);
					} else {
						delete $db->{$_};
					}
				}
			}
		}
	}
}
sub wf {
	my $f = shift;
	unlink $f or die "$!: unable to remove $f for writing.\n" if -e $f;
	open my $fh, '>', $f or die "open $f for writing: $!";
	if (@_)	{ syswrite $fh, shift }
	else	{ $fh }
}
sub runas {
	my $u = shift;
	if ($u ne 'root') {
		my ($uid, $gid) = (getpwnam $u)[2, 3];
		($(, $)) = ($gid, "$gid $gid");
		setresuid($uid, $uid, 0);
	} else {
		setresuid(0, 0, 0);
		($(, $)) = (0, '0 0');
	}
}
sub crowded {
	{subr => sub {
		my $o = shift;
		if ($o->{event} eq 'ent') {
			my $db = $o->{db};
			$db->{c} ? 1 : keys %{$db->{owner}{record}} > 1;
		}
	 }, prophet => 0};
}
sub tag {
	my $oid = shift;
	{subr => sub {
		my $o = shift;
		if ($o->{event} eq 'ent') {
			my $db = $o->{db};
			$db->{c} ? $db->{owner}{$oid} : $db->{owner}{record}{$oid};
		}
	 }, prophet => 1};
}
sub list {
	my $v = {};
	{subr => sub {
		my $o = shift;
		if ($o->{event} eq 'ent') {
			my $db = $o->{db};
			add($v, $db->{c} ? %{$db->{owner}} : %{$db->{owner}{record}});
		} elsif ($o->{event} eq 'ret') {
			$v = [map { [$_, ''.localtime $v->{$_} ] } sort { $v->{$b} <=> $v->{$a} } keys %$v];
		}
	 }, prophet => 0};
}
sub filter {
	my ($cp, $vp) = @_;
	my ($v, $f, $db, $d) = ({}, $cp->{f}{subr}, @$vp{qw/db d/});
	say {$cp->{sink}} $d if $cp->{f}{prophet};
	for (sort keys %$db) {
		my ($p, $r) = ($db->{$_}, $d . $_);
		if ($f->({event => 'ent',
			  ent => $_,
			  db => $p})) {
			say {$cp->{sink}} $r unless $p->{c};
			if ($p->{c}) {
				my $c = filter($cp, {db => $p->{c},
						     d => $r . '/'});
				$v->{$_} = {%$p,
					    c => $c} if %$c or $cp->{f}{prophet};
			} else {
				$v->{$_} = $p;
			}
		}
	}
	$f->({event => 'ret'}) or $v;
}
sub confirm ($) {
	state $s = colored('yes', 'green', 'bold') . ' or ' .
	    colored('no', 'red', 'bold') . ': ';
	print shift, ', ', $s;
	while (1) {
		chomp(my $a = <STDIN>);
		return 1 if $a eq 'yes';
		return 0 if $a eq 'no';
		print "Please answer $s";
	}
}
sub rs_unparse_wrap {
	my $o = shift;
	print colored("Writing $o->{d}", 'yellow', 'bold'), ': ';
	rs_unparse(@$o{qw/v fd/});
	say colored('done', 'green', 'bold'), '.';
}
sub main {
	my $s;
	do {
		my $c = arg_parse();
		$s = do($c->{profile} || "$ENV{HOME}/.rs.profile") || {};
		add($s, %$c);
		for ($s->{pool}, $s->{root})		{ s|(?<=[^/])$|/| if defined }
		for ($s->{prefix} ||= $s->{root} )	{ s|/$|| if defined }
	};
	print 'run-time config: ', json_unparse_readable($s);
	# mod tells us whether the database is modified.
	my ($db, $mod) = -f $s->{db} ? rs_parse($s->{db}) : {};
	while (@ARGV) {
		my $op = shift @ARGV;
		if ($op eq 'diff') {
			my $oid = shift @ARGV;
			my ($p, $_v) = $s->{pool} . $oid . '.rs';
			if (-e $p) {
				say "$p exists, will merge with new generated patch tree.";
				$_v = rs_parse($p);
			}
			my $v = diff({ih => {},
				      root => $s->{root},
				      oid => $oid,
				      ts => time}, {db => $db,
						    ign => $s->{ign} ? do $s->{ign} || die "$s->{ign} is bad.\n" : undef,
						    d => ''});
			if ($s->{dry}) {
				push @ARGV, 'tag', $oid;
			} else {
				$mod = 1;
				merge($v, $_v) if $_v;
				rs_unparse_wrap({v => $v,
						 fd => fileno wf($p),
						 d => "compiled package $p"});
			}
		} elsif ($op eq 'patch') {
			my $f = shift @ARGV;
			#   v is the parsed value of the patch, and can be cut using subtree switch,
			# the final patch to apply is stored in p.
			my $v = my $p = rs_parse($f);
			if (exists $s->{subtree}) {
				$p = {};
				grow($p, $v, $_) for flatten($s->{subtree});
			}
			my ($oid) = $f =~ m|([^/]*).rs$|;
			patch({root => $s->{root},
			       oid => $oid,
			       ts => time}, {v => $p,
					     db => $db,
					     d => ''});
			$mod = 1;
		} elsif ($op eq 'remove') {
			my $oid = shift @ARGV;
			rm({root => $s->{root},
			    oid => $oid,
			    pool => $s->{pool},
			    patch => my $p = {}}, {db => $db,
						   d => ''});
			$mod = 1;
			my $ts = time;
			for (keys %$p) {
				patch({root => $s->{root},
				       oid => $_,
				       ts => $ts}, {v => $p->{$_}{p},
						    db => $db,
						    d => ''});
			}
		} elsif ($op eq 'compile') {
			my $root;
			if ($root = not $>) {
				# drop root privilege before compile, as suggested by many packages.
				my $u = $s->{'compile-as'} || $ENV{USER};
				if ($u eq 'root') {
					say colored('You are compiling as root!', 'red', 'bold');
					$root = 0;
				} else {
					runas($u);
				}
			}
			my ($p, $o, $oid, $pkg, $d) = (abs_path(shift @ARGV), getcwd());
			chdir($s->{'compile-in'} || '.') or die $!;
			if (-d $p) {
				$oid = shift @ARGV;
				if ($s->{prepared}) {
					$d = $p;
				} else {
					mkdir $d = $oid or die $!;
					xsh(0, qw/git clone --shared/, '--branch=' . ($s->{branch} || $oid),
					    $p, $d);
				}
			} else {
				($oid) = $p =~ m|([^/]*).tar.\w+$|;
				($d) = (xsh(1, qw/tar -xvf/, $p))[0] =~ m|([^/\n]*)| or die 'bad tarball.';
			}
			($pkg) = $s->{package} || $oid =~ m|(.*)-|;
			chdir $d or die "chdir $d: $!.";
			my $b = do {
				my ($b, $v) = (do $s->{build}, $pkg);
				$b = $b->($s) if ref $b eq 'CODE';
				$v = $b->{$v} until ref $v or not $v;
				$v;
			};
			xsh({'feed-stdin' => 1}, $b->{'pre-configure'}, 'bash') or die 'pre-configure failed.' if $b->{'pre-configure'};
			unless ($b->{'no-configure'}) {
				local %ENV = %ENV;
				xsh(0, qw/autoreconf -iv/) or die 'autoreconf failed.' unless -e 'configure';
				my @p;
				if ($s->{bootstrap}) {
					$ENV{CPPFLAGS} = "-I$s->{prefix}/include" unless $b->{'no-cppflags'};
					$ENV{LDFLAGS} = "-L$s->{prefix}/lib -Wl,-I" . linker($s);
				}
				push @p, "--prefix=$s->{prefix}";
				my $e = $b->{environment};
				$ENV{$_} = $e->{$_} for keys %$e;
				xsh(0, './configure', @{$b->{switch}}, @p,
				    {to => *STDERR,
				     from => *STDOUT,
				     mode => '>'}, qw/| less --quit-on-intr --RAW-CONTROL-CHARS/) or die 'configure failed.';
			}
			xsh({'feed-stdin' => 1}, $b->{'post-configure'}, 'bash') or die 'post-configure failed.' if $b->{'post-configure'};
			xsh(0, 'make', $s->{jobs} ? "--jobs=$s->{jobs}" : (), @{$b->{'make-parameter'}}) or die 'make failed.' unless $b->{'no-make'};
			xsh({'feed-stdin' => 1}, $b->{'post-make'}, 'bash') or die 'post-make failed.' if $b->{'post-make'};
			# since the following is installation process we need to switch back to root.
			runas('root') if $root;
			xsh(0, qw/make install/, @{$b->{'make-install-parameter'}}) or die 'make install failed.';
			xsh({'feed-stdin' => 1}, $b->{'post-make-install'}, 'bash') or die 'post-make failed.' if $b->{'post-make-install'};
			# do some cleaning.
			unless ($s->{prepared} or $s->{'no-rm'}) {
				my $cwd = getcwd();
				xsh(0, qw/rm -rf/, "../$d") if confirm "'rm -rf ../$d' on $cwd";
			}
			# return to where we started.
			chdir $o or die "chdir $o: $!.";
			# the next steps.
			push @ARGV, 'diff', $oid, 'tag', $oid;
		} elsif ($op =~ /^(tag|crowded|list|which)$/) {
			no warnings 'once';
			*which = sub {
				my $r = shift;
				if ($r =~ m{^/}) {
					die colored("Absolute path $r not prefixed by $s->{root}", 'red', 'bold'), ".\n" unless 0 == index $r, $s->{root};
					$r = substr $r, length $s->{root};
				}
				my ($d, @p) = (0, split m{/}, $r);
				{subr => sub {
					my $o = shift;
					if ($o->{event} eq 'ent') {
						my $u = $d >= @p || $o->{ent} eq $p[$d];
						$d += 1 if $u and $o->{db}{c};
						$u;
					} elsif ($o->{event} eq 'ret') {
						$d -= 1, 0;
					}
				 }, prophet => 1};
			} if $op eq 'which';
			my ($tab, $pid) = {tag => 1,
					   crowded => 0,
					   list => 0,
					   which => 1};
			local $SIG{PIPE} = 'IGNORE';
			do {
				pipe my $r, my $w or die $!;
				$pid = xsh({asynchronous => 1},
					   qw/less -R/, {to => *STDIN,
							 from => $r,
							 mode => '<'});
				close $r;
				print $w json_unparse_readable(filter({sink => $w,
								       f => $::{$op}(splice @ARGV, 0, $tab->{$op})}, {db => $db,
														      d => ''}));
			};
			# we must wait here or we will lose control-terminal.
			waitpid $pid, 0;
		}
	}
	if ($mod)	{ rs_unparse_wrap({v => $db,
					   fd => fileno wf($s->{db}),
					   d => "database $s->{db}"}) }
	else		{ say colored('Database not touched', 'green'), '.' }
}

=head1 NAME

App::rs - The package manager for RSLinux

=head1 SYNOPSIS

    # compile, install, and generate package.
    rs compile <tarball>
    rs compile <git-directory> <oid>
    rs --prepared compile <source-directory> <oid>

    # generate package after manual installation.
    rs diff <oid>

    # install a previously compiled package.
    rs patch <path/to/oid.rs>

    # remove a package.
    rs remove <oid>

    # show the package tagged as oid.
    rs tag <oid>

=head1 DESCRIPTION

RSLinux was born out of desire for freedom. Back in 2012, I was using
ArchLinux, as with many distributions at that time, it's switching to
systemd, and I would be forced to switch to it if I chose to update. It
frustrated me deeply, as I always seek freedom, from a very young age, and I
knew from my own experience that no matter how wonderful a thing is, it
will become a demon that haunts me once I'm being forced to do it. I made
up my mind to create something of my own so that I have complete freedom
to choose how it would be.

At first, I got my hand dirty with LFS, succeeded and got pretty satisfied
with it. Later in 2013, I made it again without following the LFS book, I
tried a different bootstrapping process with what I thought was right and
necessary, and it fits my mind much better. I typically rebuild my system
on an annual basis, after I did it in 2014 I gradually realized its problem,
without a package manager, thus an easy way to remove installed package,
I tended to dislike denpendency, and prefer a minimalist system, which
prevented me to explore since I knew I would have no easy way to clean up the mess
after I installed a lot of things, experimented with them a bit, and then
decided that I don't want them anymore.

I knew it was bad, and something to be dealt with. In the end of 2015, I
was working on something that's recursive, and it inspired me to
write a simple and elegant package manager B<rs>, since directory and files,
which a package manager deals everyday, recursiveness is in their nature.

B<rs> keeps a database of the metadata of every file that you didn't ask
it to ignore, you will typically ask it to ignore something like C</tmp>,
C</proc>, etc., if you're using it to manage system wide packages. With
B<rs> you compile and install a package from source as usual, and when the
installation process is done, you run C<rs diff oid>, B<rs> then starts
a scan of the root directory into which you just installed your package,
and during the scan process, it compares what's actually there with the
database, calculate the difference between them as well as updating the
database, and when the scan process ends, the difference is then tagged
as C<oid> in the database, serialized and stored as C<oid.rs>, and the
database is saved as well.

This serialized difference is what B<rs> considers as a package, and it could
be transferred across machines and installed using C<rs patch>, it's very
much like a tarball, but I could not just use a tarball since I need to maintain
all these metadata in the database when patching, instead of parsing a tarball
I thought I might just use a trivial binary format that integrates well with
B<rs> and suits my need.

Being someone who came from LFS, I knew this is a game changer, it gave me a
complete new experience, besides the ability to explore without any hesitation,
I could easily upgrade, or switch between multiple versions of package;
I could now compile once on desktop, and then install the compiled package
on laptop, or vps; I could select a few packages, patch them, and then make
a bootable usb disk or cdrom, or a complete environment that's suitable to
put into a container and run web service. I sincerely believe anyone who
likes LFS will like it, and anyone who likes the freedom of LFS but hated
the inconvenience will like it also, since B<rs> eliminates ninety percent
of the inconvenience yet without sacrificing even a tiny bit of the freedom.

RSLinux is a Linux distribution, but not necessarily so, it's a way of doing
things more. You do not need to take a full commitment using it as a
distribution, there're almost always packages that you care about more and
want to follow closely, while other people haven't packaged it for you,
B<rs> is a perfect choice for this, you could use B<rs> to properly manage
packages somewhere inside your home directory while still using your
favorite distribution.

Till this day, I still haven't tried systemd once, I don't know one single
objective reason why I don't use it, but it's true enough that it's the
very first motivation that got all these things started. I guess that's just
how the world is, few things are objective while basically everything is
subjective. Nevertheless, the goal of B<rs> is to avoid all these subjective
feelings and views on how a distribution should be made, which init system
should be used, what configure switches, compiling flags should be passed,
whether stable version should be preferred over bleeding edge version or the
other way around, how a filesystem hierarchy should be laid out. Whatever
you feel is right, you just go for it, and what B<rs> does is to make this
process easier, I would say that it's easy enough now, all the build instructions
I used to build a distribution that I use everyday are only literally one
hundred lines long.

Still, RSLinux will never be easier than a classic distribution where other
people do everything for you, but there're still many things to do and
improve, and I do think in the long run the effort will be negligible
and the reword will be immense. If you never tried LFS or something like
it before, I suggest you use B<rs> to manage a couple of packages user wide
while retain your distribution untouched, once you get your way around it,
then maybe consider to jump on the ship, there's nothing to be afraid of.

=head1 OPTIONS

=over 4

=item * --root=<dir>

Specify the directory in which B<rs> will operate, it will scan this
directory for newly installed files during a C<diff> operation, and
will put or remove files under it during a C<patch>, C<remove> operation
respectively.

=item * --db=<file>

Specify the database where all the metadata of the files and directories
in C<root> is stored. If it doesn't exist yet B<rs> will create an empty
one for you. But you should always specifiy it since it's used by
all of the commands.

=item * --pool=<dir>

The direcory where a generated package will be stored during a C<diff>
command. It's also occasionally used when you C<remove> a package, see
the L</remove> command for more detail.

=item * --prefix=<dir>

Definitely the most used compiling option, all packages use it somewhere
somehow during the compiling process. Defaults to the directory specified
by C<--root>.

=item * --compile-as=<user>

Typically you need to run as root if you want to install a package globally
into the system directory, however most packages recommend compiling as
a non-privileged user and few even make it mandatory. If you specify this
option, and you're running as root, B<rs> will switch to the user specified
when compiling.

=item * --compile-in=<dir>

The directory to change into when compiling, if you use it with C<--compile-as>
make sure the directory is writable by that user.

=item * --build=<file>

Building instructions, see L</build>.

=item * --ign=<file>

This is the file that specifies which directory/file should be ignored when doing
a C<diff>, see L</ignore>.

=item * --profile=<file>

Since many options are used everytime, it would be really tedious to type them
out each time you run B<rs>, a profile allows you to collect these options
into a file so that you do not have to do it everytime, and you could easily
switch between multiple profiles. See L</profile>.

Not surprisingly, options in the command line take precedence over the
ones in a profile.

=item * --package=<package name>

B<rs> will try to use the build instructions associated with this package
name. Normally you don't have to specifiy this, since it's automatically
calculated from C<oid>, for example, if you use C<perl-v5.22.3> as C<oid>,
the package name will be C<perl>. Nontheless sometimes it could come in
handy.

=item * --subtree=<relative path>

Typically when you install a package using C<rs patch> everything inside
it will be installed, this option allows you install only some part of it.
You could pass this option multiple times.

=item * --prepared

If you pass a directory as arugument to C<rs compile>, B<rs> will assume
that it's a git directory, use this option if it's a prepared source
directory instead.

=item * --branch=<branch or tag>

Checkout this branch or tag when compiling from a git directory. By default
B<rs> will try to use the C<oid> you specified as the branch or tag to checkout.

=item * --bootstrap

Let B<rs> know that you're bootstrapping the toolchain, additional flags to
set include path, library path, and dynamic interpreter will be passed to
related compiling process, so that the final toolchain is self-contained.

=item * --jobs=<number>

How many parallel jobs should be used during C<make>.

=item * --no-rm

By default B<rs> will ask you if you want to remove the temporary build
directory if you're compiling from a tarball or a git directory, if you
toggle this option it will not try to remove the build directory.

=back

Note that all options should be specified before any command.

In the following text sometimes I refer to the value of an option as
the name of the option with the preceding C<--> removed, like C<pool>
to mean the value of the option C<--pool>.

=head1 COMMANDS

=over 4

=item diff

The C<diff> command takes one argument, C<oid>, it traverses the root
directory and tag the difference between the content there and what's
recorded in C<db> as C<oid>, and serializes it as C<oid.rs> in C<pool>.

You can choose anything you want as C<oid>, usually you want to use
something meaningful like the package name with the package version appended,
such as C<gcc-6.4.0>.

If the C<oid.rs> already exists in C<pool>, the new difference will be merged with
the old, this way the C<diff> command could do limited amending, that's most
useful when you forgot to install something, like documentation, you could
always install it later and merge with the content you installed previously.
See L</AMEND> for why amending using C<diff> is limited and how to do
arbitrary amending.

=item compile

The C<compile> command integrates the C<diff> and C<tag> commands to make
it easier for you to install a package from source, it automatically
compiles and installs a package, then does a C<diff> command followed
by a C<tag> command.

The compiling instructions are taken from the L</build> configuration file
with the entry associated with the package name. The package name could
be set explicitly by the C<--package> option, or more commonly it's derived
from C<oid> by using the longest prefix of it before the C<-> character,
for example, with C<man-pages-4.15> as oid the package name will default to
C<man-pages>, and with C<perl-v5.22.3> it will be C<perl>.

There're three types of compile commands, compile from a tarball, a git directory,
or a prepared source tree.

=over 4

=item * compile <tarball>

B<rs> will extract, compile, then install the tarball in the direcory
C<compile-in>, or the current directory if it's not specified.
The filename of the tarball, with the extension name like C<.tar.gz>,
C<.tar.xz>, etc. stripped, is used as C<oid> to the C<diff> command. For
example, if the tarball is C<man-pages-4.15.tar.xz>, the C<oid> will be
derived as C<man-pages-4.15>, just C<mv> the tarball if you want to change
the C<oid> to something different.

=item * [--branch=<branch>] compile <git-directory> <oid>

B<rs> will do a C<git clone> from the specified git directory, checkout branch
or tag specified by the C<--branch> option or C<oid> if absent, in C<compile-in>,
and then compile and install the package.

=item * --prepared compile <source-directory> <oid>

B<rs> will C<chdir> into the prepared source directory and start the compiling
process, thus the C<compile-in> directory is ignored in this case. It's
useful when you need more complex preparations of the source like applying some
patches, or initializing git submodules, etc.

=back

The C<compile> command really covers ninety percent of the case, but it may
not be flexible enough to compile every package in the wild, but that's
actually okay, since you could always do a manual installation followed
by a C<diff> command.

=item patch

C<patch> takes one argument, a compiled package file <path/to/oid.rs>, which
is produced by a previous C<diff> command, it then installs the package into
C<root> and tag it as C<oid>.

Optionally, one or more C<--subtree> could be provided so that only part of
the package is installed, for example, C<--subtree=bin/> will instruct B<rs>
to only install anything under the C<bin> directory of the package.

=item remove

C<remove> takes one argument, the C<oid> of the package to be removed.
B<rs> will remove both the content of the package under C<root> and
its metadata in the database.

Sometimes, different packages install files into the same location. B<rs>
takes care of that by recording a list of owners associated with a file,
along with the timestamps when ther're installed, that's why you are seeing
all the C<oid>s floating around the manual, it means I<owner's id>. And
when you remove a package, a file is removed if and only if this package
is the most recent owner of it, and if it's not, nothing will happen,
only the entry in the owner recording list will be removed. Also, if
you're removing a package that's indeed the most recent owner of a file,
but this file has multiple owners, then the file will be restored
to the version of the second most recent owner. That's why I said earlier
that the C<--pool> option is used not only when diffing, but also removing
sometimes. Suppose the second most recent owner is C<oid>, then B<rs> will
try to parse the compiled package C<oid.rs> in C<pool>, and restore the file
according to it.

=item tag

C<tag> takes one argument C<oid> and displays a list of files which are
owned by it, followed by the detailed metadata about them in the database
as JSON.

=back

=head1 CONFIGURATION FILES

All configuration files are evaluated using Perl's C<do> statement and
a hash reference is expected as the return value, with the exception
that the L</build> configuration could also return a code reference.

You don't necessarily have to know Perl to write the configuration files,
you could just write them in JSON with the C<:> separator substituted
as C<< => >>. That being said knowing a bit of Perl surely will help
you use B<rs> to its best potential, and you don't have to be a Perl
expert to write it, so don't be afraid.

See also the released VM image to have a look at some sane configuration
files and get you started.

=over 4

=item profile

This is a configuration file which collects options that you always need
to specifiy. The keys of the hash are option names while the values are,
well, corresponding values. A typical profile looks like:

    {db => '<file>',
     build => '<file>',
     ign => '<file>',
     pool => '<dir>',
     'compile-as' => '<user>',
     'compile-in' => '<dir>',
     root => '<dir>',
     jobs => <number>}

=item build

This file specifies the building instructions, it's only used by the
C<compile> command, the keys are package names while the values are
hash references that detail the instructions on how the build process
should be done. In the following text that explains the build process,
you'll often see I<the value of something>, or I<if something exists>,
it's talking about this hash.

For many packages the build instruction is exactly the same, you could
alias the build instruction of a package to another one by setting it
to the name of the other package.

As previous mentioned, instead of a hash reference, the C<build> file
could also return a subroutine which will be called with a collection
of the options, you could then return the building instructions differently,
depending on whether you're bootstrapping or not, for an example.

The build process is divided into several steps:

=over 4

=item 1. pre-configure

If C<pre-configure> exists, the value of it should be a string and
B<rs> will try to evaluate it with C<bash>, before running the
C<configure> script.

Usually something like C<autogen.sh> or C<bootstrap> is run in this step.

=item 2. configure

Unless there's a true value in the C<no-configure> slot, B<rs> will
try to run the <configure> script, if it doesn't exist B<rs> will
run C<autoreconf> to make one. A C<--prefix> switch is always passed,
using the value of the C<prefix> option, along with the value of
C<switch> slot, which if exists, should be an array reference of configure options
that should be passed to the C<configure> script.

B<rs> will pipe the output of C<configure> to the pager C<less>, since
C<configure> usually outputs important information about if a package
is properly configured, you should briefly scroll over the outputs, and
exit the pager normally using the C<q> key, else you should type C<Ctrl-C>
to abort the compile process if you think something is wrong.

=item 3. post-configure

Like C<pre-configure>, C<post-configure> should contain a string to
be evaluated by C<bash>, it's run after the C<configure> script.
It's usually coupled with C<no-configure> to build packages that
don't use a C<configure> script.

=item 4. make

Unless C<no-make> is true, B<rs> will run C<make> to build the package,
C<make-parameter> could be a reference to list of parameters that should
be passed to make, the command line option C<jobs> tells how many parallel
processes to use.

=item 5. post-make

The value of C<post-make> should be a string to be evaluated by C<bash> if
exists, it's run after C<make> is finished, most commonly something
like C<make check> or C<make tests> happens here.

=item 6. make install

B<rs> will run C<make install> to install the compiled package, the value of
C<make-install-parameter> could be an array of parameters to be passed to C<make>.

=item 7. post-make-install

The value of C<post-make-install>, if exists, should be a string to be evaluated by
C<bash>, it's run after C<make install>, if you want to make some symbolic links,
remove some undesired files after installation, that's the place to go.

=back

An example C<build> file:

    {gmp => {'post-make' => 'make check'},
     mpfr => 'gmp',
     'man-pages' => {'no-configure' => 1,
		     'no-make' => 1},
     ncurses => {switch => [qw/--with-shared --without-debug/]},
     'XML-Parser' => {'no-configure' => 1,
		      'post-configure' => 'perl Makefile.PL',
		      'post-make' => 'make test'},
     git => {'make-parameter' => [qw/all doc/],
	     'make-install-parameter' => [qw/install-doc install-html/]}}

=item ignore

This is typically used when you're installing into a system-wide location,
you certainly would not want to include the content of C</proc>, C</sys>
into your package during a C<diff> command, and this file is where to
put it.

If you want to ignore a file/directory completely, at the top level,
add a hash entry with the name as the key and C<1> as the value. For
a directory, you may want to be more specific, like ignore only part
of it while care for the rest, then you should make the value a hash
to specify what should be ignored under this directory, and if some
of sub-directories should also be partially ignored then you nest a
hash inside again. So yeah, it's recursive and like a tree, naturally.

Suppose you want to ignore C</proc> and </sys> completely,
C<resolv.conf> and C<hosts> inside C</etc> but not the others, you
could write:

    {proc => 1,
     sys => 1,
     etc => {'resolv.conf' => 1,
	     hosts => 1}}

=back

=head1 ADVANCED

=head2 AMEND

In the description of the C<diff> command a brief introduction to amending
is included, but it's limited and you could only add or overwrite things.
So why is that? You may get the impression now that B<rs> acts more like a
version control system than a traditional package manager, while that's true,
it's also not a version control system, it expects the packages that it manage
to be independent to an extent, i.e. during the installation of a package
a file/directory of another package will not suddenly be removed, that's really
normal for a vcs since a patch in a vcs is always applied to a previous state,

=cut

